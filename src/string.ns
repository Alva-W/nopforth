forth
32 value bl

: emit ( b -> )   here 1!  here 1 type ;

: cr      10 emit ;
: space   bl emit ;
: spaces ( u -> )   for space next ;

: printable? ( c -> flag )    bl 127 within ;

: char ( -> b )     bl word drop 1@ ;
macro
: [char] ( -> b )   char ` lit ;
forth

record:
   cell            field: str-len
   cell align cell field: str-data
value /str

: str! ( a len dst -> )      tuck  str-len !  str-data ! ;
: str>mem ( str -> a len )   dup str-data @  swap str-len @ ;
: str, ( a len -> )
   here push  /str allot  here push
   tuck mem,  pop swap pop str! ;

macro
: strlit ( a len -> )
   ` branch-unresolved  here push push  \ r: 'str 'resolve
   str,  pop ` then  pop ` lit ;

macro : "            [char] " word  ` strlit ;
forth : " ( -> a )   here  [char] " word str, ;

: print ( str -> )   str>mem type ;
: println            print cr ;

macro : ."   ` "  [f'] print call, ;
forth : ."   [char] " word type ;

forth
: str-len= ( str1 str2 -> ? )   str-len @  swap str-len @ = ;

: str= ( str1 str2 -> ? )
   2dup str-len= not if  drop drop false exit  then
   str-data @ swap  str>mem  mem= ;

: str-size ( str -> size )   str-len @ /str + ;

: str-copy ( str dst -> )
   push  str>mem
   r@ /str +  over r@ str!
   pop str-data @  swap move ;

: str-concat ( src dst -> )
   push  str>mem  r@ str>mem +  swap dup push  move
   pop  pop str-len  +! ;


: s>z ( a u -> a' )     here push  dup allot  r@ swap move  0 1,  pop ;
: zlen ( a -> u )       a! 0 begin 1@+ while 1 + repeat ;
: z" ( -> a )           [char] " word s>z ;
: z>mem ( a -> a' u )   dup zlen ;

macro
: memlit ( a len -> )
   dup push  ` branch-unresolved  here push push
   \ r: len addr-of-string-start addr-of-branch-dst
   mem,  pop ` then  pop ` lit  pop ` lit ;

macro : ,"   [char] " word  ` memlit ;
forth : ,"   [char] " word   here over allot  swap move ;


: depth ( -> u )   S0 sp@ - 8 /  2 - ;


