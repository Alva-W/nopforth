forth
: cfa ( a -> a' )   >cfa @ ;

macro
: `   next-word mlatest dfind dup 0 = if abort then  cfa call, ;

: asave   ` a    ` push ;
: arest   ` pop  ` a! ;

: begin ( -> a )        here ;
: while ( a -> a' a )   ` if swap ;
: again ( a -> )        ` branch ;
: repeat ( a a' -> )    ` again ` then ;

: for ( -> a a' )    ` push ` begin ` r@ ` while ;
: next ( a a' -> )   ` rdec ` repeat ` rdrop ;

: 2push   ` push ` push ;
: 2pop    ` pop ` pop ;
: 2dup    ` over ` over ;

: not   0 ` lit ` = ;


( macro -> forth )
\ We define forth words using the macros, so they can be used interactively
forth
: dup    dup ;
: drop   drop ;
: swap   swap ;
: over   over ;
: nip    nip ;
: 2dup   2dup ;

: a     a ;
: a!    a! ;
: @     @ ;
: @+    @+ ;
: b@    b@ ;
: b@+   b@+ ;
: !     ! ;
: !+    !+ ;
: b!    b! ;
: b!+   b!+ ;

: +      + ;
: -      - ;
: *      * ;
: /mod   /mod ;
: /      /mod nip ;
: mod    /mod drop ;

: lshift   lshift ;
: rshift   rshift ;

: and      and ;
: or       or ;
: xor      xor ;
: ~        ~ ;

: not      not ;
: =        = ;
: ~=       ~= ;
: <        < ;
: <=       <= ;
: >=       >= ;

: negate   negate ;

: tuck ( x y -> y x y )   swap over ;
: within ( u lo hi -> flag )  push over <=  swap pop <  and ;
: min ( a b -> a|b )          2dup < if drop exit then nip ;


( Dictionary )
forth
: find ( a u -> a'|0 )   latest @ dfind ;

: ' ( -> a )      next-word            find dup 0 = if abort then  cfa ;
: f' ( -> a|0 )   next-word flatest @ dfind dup 0 = if abort then  cfa ;

macro
: [']    '  ` lit ;
: [f']   f' ` lit ;
forth

: allot ( n -> )   here +  h ! ;

: pfa ( 'def -> 'data )   \ return a pointer to a definition's data area
   cfa 5 + ;

: (does>)   \ runtime for does>
   latest @ @ cfa
   pop swap call!   \ compile a call to the code following does>
   0 hole ! ;       \ do not transform the previous call into a jump

macro
: does>
   [f'] (does>) call,  \ compile a call to the runtime for does>

   \ at runtime R has the address of the data area for the definition,
   \ compile a pop to retrieve that address
   ` pop ;
forth

: created ( a u -> )
   entry,
   >cfa  here swap !  \ store next data address as the cfa
   0 call,            \ compile a dummy call
   does> ;

: create   next-word created ;

: variable   create 0 , ;
: value      create ,  does> @ ;

: ?find ( -> a )   next-word find   dup 0 = if abort then ;

macro
: to ( n -> )   ?find pfa  ` lit ` ! ;
forth
: to ( n -> )   ?find pfa  ! ;

8 value cell
: cells ( -> u )   cell * ;

: marker
   here              \ save current HERE so the marker definition removes itself
   forth create
      ,              \ 0:       dictionary pointer
      flatest @ @ ,  \ cell:    next to last forth definition
      mlatest @ ,    \ 2 cells: last macro definition
   does>
      dup        @ h !
      dup cell + @ flatest !
       2 cells + @ mlatest ! ;


( Memory utilities )
forth
: advance ( a u n -> a+n u-n )   swap over  - push + pop ;

: move ( src dst u -> )
   push push a! pop pop
   begin dup while
     over b@+ swap b!
     1 advance
   repeat
   drop drop ;

: +! ( n a -> )   swap over  @ +  swap ! ;
: mem, ( a u -> )   here over allot  swap move ;

: mem= ( a1 a2 u -> f )
   dup 0 = if  drop drop drop  -1 exit  then
   push  over b@ over b@ ~= if  drop drop rdrop  0 exit then
   push  1 +  pop pop 1 advance  mem= ;

: search ( a u b -> a' u' )
   over 0 = if  drop exit  then
   swap push  over b@ over = if  drop pop exit  then
   pop swap push  1 advance  pop search ;

: head ( a u b -> a u' )   push 2dup pop search  nip - ;
: tail ( a u b -> a u' )   search  dup if 1 advance then ;

: align ( a u -> a' )   1 -  swap over +  swap ~ and ;

0 value record:
: field: ( offset size alignment -> offset+size' )
   create   swap push  align dup ,  pop +
   does> ( a -> a' )   @ + ;


( Strings )
forth
32 value bl

: emit ( b -> )   here b!  here 1 type ;

: cr      10 emit ;
: space   bl emit ;
: spaces ( u -> )   for space next ;

: printable? ( c -> flag )    bl 127 within ;

: char ( -> b )     bl word drop b@ ;
macro
: [char] ( -> b )   char ` lit ;
forth

record:
   cell 1    field: str-len
   cell cell field: str-data
value /str

: str! ( a len dst -> )      tuck  str-len !  str-data ! ;
: str>mem ( str -> a len )   dup str-data @  swap str-len @ ;
: str, ( a len -> )
   here push  /str allot  here push
   tuck mem,  pop swap pop str! ;

macro
: strlit ( a len -> )
   ` branch-unresolved  here push push  \ r: 'str 'resolve
   str,  pop ` then  pop ` lit ;

macro : "            [char] " word  ` strlit ;
forth : " ( -> a )   here  [char] " word str, ;

: print ( str -> )   str>mem type ;
: println            print cr ;

macro : ."   ` "  [f'] print call, ;
forth : ."   [char] " word type ;

forth
: str-len= ( str1 str2 -> ? )   str-len @  swap str-len @ = ;

: str= ( str1 str2 -> ? )
   2dup str-len= not if  drop drop 0 exit  then
   str-data @ swap  str>mem  mem= ;

: str-size ( str -> size )   str-len @ /str + ;

: str-copy ( str dst -> )
   push  str>mem
   r@ /str +  over r@ str!
   pop str-data @  swap move ;

: str-concat ( src dst -> )
   push  str>mem  r@ str>mem +  swap dup push  move
   pop  pop str-len  +! ;


: s>z ( a u -> a' )     here push  dup allot  r@ swap move  0 b,  pop ;
: zlen ( a -> u )       a! 0 begin b@+ while 1 + repeat ;
: z" ( -> a )           [char] " word s>z ;
: z>mem ( a -> a' u )   dup zlen ;

macro
: memlit ( a len -> )
   dup push  ` branch-unresolved  here push push
   \ r: len addr-of-string-start addr-of-branch-dst
   mem,  pop ` then  pop ` lit  pop ` lit ;

macro : ,"   [char] " word  ` memlit ;
forth : ,"   [char] " word   here over allot  swap move ;


: depth ( -> u )   S0 sp@ - 8 /  2 - ;


( Pictured numeric conversion )
forth
: digit ( n -> n' )   dup 9 >  7 and +  48 + ;

: hold ( count rem b -> b count+1 rem )   swap push  swap 1 + pop ;

: <# ( n -> 0 n )               0 swap ;
: #  ( n -> ... count rem )     base @ /mod swap digit hold ;
: #> ( ... count rem -> a u )   asave  drop  here a!  dup push for b!+ next  here pop  arest ;
: #s ( n -> ... count rem )     begin # dup while repeat ;

: abs ( n -> |n| )   dup 0 < if negate then ;
: sign ( n -> )   0 < if  [char] - hold  then ;

: (.) ( n -> )   dup push abs <#  #s pop sign #> ;
: . ( n -> )     (.) type space ;

: .S   depth S0 16 - swap for  dup @ . 8 -  next drop  ." <- top " ;

: spfill ( u -> )    16 swap - 3 * spaces  space ;
: .addr ( a -> )     base @ push hex  <# cell for # # next #> type  pop base ! ;
: hb. ( u -> )       base @ push hex  <# bl hold # # #> type  pop base ! ;
: bytes ( a u -> )   swap a! for b@+ hb. next ;
: c. ( c -> )        dup printable? not if  drop [char] .  then  emit ;
: text ( a u -> )    swap a! for b@+ c. next ;
: line ( a u -> )    over .addr 2 spaces  2dup bytes dup spfill  text cr ;

: dump ( a u -> )
   begin dup while
      2dup 16 min line
       dup 16 min advance
   repeat
   drop drop ;


( Read-eval loop )
forth
0 value 'rel
: rel   'rel execute ;

0 value 'warm
: warm   'warm dup if execute then  bye ;

: .abort ( str -> )
   dup 0 ~= if println exit then  drop
   inbuf @ inpos @ here str!  here print  [char] ? emit cr ;

: abort ( str -> )         .abort reset-input resetstacks warm ;
: ?abort ( flag str -> )   push  if pop abort then  rdrop ;

: ?underflow
   depth 0 >= if exit then
   " stack underflow!" println  0 abort ;

: evaluate
   next-word dup 0 = if  drop drop exit  then
   eval ?underflow evaluate ;

variable 'refill  \ must be set before use
: refill               'refill @ execute ;
: refilled? ( -> n )   inpos @ inused @ ~= if -1 exit then  refill ;

anon: begin refilled? while evaluate repeat ;  to 'rel


( Files )
forth
: (open-create) ( a u mode syscall# -> fd )   push push s>z pop pop syscall2 ;
: create-file ( a u mode -> fd )   85 (open-create) ;
: open-file ( a u mode -> fd )   2 (open-create) ;

: read ( a u fd -> n )   sysread ;
: read-byte ( fd -> b|-1 )
   push here 1 pop read 1 = if  here b@ exit  then -1 ;

: read-line ( a u fd -> n )
   push push a! pop pop over  for
     dup read-byte dup b!+
     dup -1 = if  drop drop pop - exit  then
         10 = if  drop pop - 1 + exit  then
   next
   drop ;

: write ( a u fd -> n )   syswrite ;
: write-byte ( b fd -> n )   push  here b!  here 1 pop write ;
: write-line ( a u fd -> n )
   dup push write  10 pop write-byte
   1 ~= if  drop -1 exit  then 1 + ;

: close ( fd -> n )   3 syscall1 ;
: position-file ( n ref fd -> n' )   swap push swap pop 8 syscall3 ;
: file-position ( fd -> n' )   push 0 1 pop position-file ;


( File loading )
: input@ ( -> fd buf tot used pos 'refill )
   infd @ inbuf @ intot @ inused @ inpos @ 'refill @ ;

: input! ( fd buf tot used pos 'refill -> )
   'refill ! inpos ! inused ! intot ! inbuf ! infd ! ;

: save-input
   pop pop  input@ push push push push push push  push push ;

: restore-input
   pop pop  pop pop pop pop pop pop input!  push push ;

: fsize ( fd -> u )   push 0 2 pop position-file ;

: sysmmap ( addr length prot flags fd offset -> addr' )   9 syscall6 ;
: sysmunmap ( addr length -> err )   11 syscall2 ;

: fmap ( fd -> a u ) \ PROT_READ MAP_PRIVATE
   dup push fsize  0 over 1 2 pop 0 sysmmap  swap ;

: inbuf+                inbuf +! ;
: intot-                negate intot +! ;
: setup                 0 inpos !  inused @ dup inbuf+ intot- ;
: ?skip ( a u -> a' )   0 = if exit then   dup b@ 10 = if 1 + then ;
: eolscan               inbuf @ intot @ 10 scan  ?skip ;
: frefill ( -> n )      setup  eolscan inbuf @ -  dup inused ! ;

: included ( a u -> err )
   0 open-file dup 0 < if exit then
   save-input  dup dup fmap 0 0 ['] frefill input!
   push rel pop
   close drop  inbuf @ intot @ sysmunmap drop
   restore-input  0 ;

: include   10 word included " can't include file" ?abort ;


( Shell utilities )
: #!  ` \ ;

: #args ( -> u )      S0 @ @ ;
: 'arg ( u -> a )     1 + cells  S0 @ + ;
: arg ( u -> a u' )   'arg @ z>mem ;
: 'env ( u -> a )     #args 1 + + 'arg @ ;

variable arg-offset
: next-arg ( -> a u )
   arg-offset @  dup #args >= if  drop 0 0 exit  then
   arg  1 arg-offset +! ;

create senv /str allot
: env>mem ( i -> a u )          'env z>mem ;
: >env-name ( a u -> a u' )     [char] = head  senv str! ;
: >env-value ( a u -> a' u' )   [char] = tail  senv str! ;
: env-name ( i -> str )         env>mem >env-name  senv ;
: env-value ( i -> str )        env>mem >env-value senv ;
: env= ( str i -> ? )           env-name str= ;
: env-end? ( i -> ? )           'env 0 = ;

: (getenv) ( name i -> value )
   dup env-end? if  drop drop 0 exit  then
   2dup env= if  nip env-value exit  then
   1 + (getenv) ;

: getenv ( name -> value )   0 (getenv) ;


marker empty

: term-refill ( -> n )
   ." ok "
   0 inpos !  inbuf @ intot @ infd @ read-line  dup inused !
   dup 0 = if cr then ;

: term-loop   0  here 128 dup allot  0 0 ['] term-refill input!  rel ;

' abort 'abort !

anon:
   #args 1 = if  banner  ['] term-loop to 'warm  term-loop exit  then
   2 arg-offset !  1 arg included " can't run file" ?abort
; execute
