forth
: abort0 ( -> )   0 0 abort ;
: cfa ( a -> a' )   >cfa @ ;

macro
: [compile] ( -> )
   next-word mlatest dfind dup 0 = if abort0 then  cfa call, ;

: asave ( -> )   [compile] a    [compile] push ;
: arest ( -> )   [compile] pop  [compile] a! ;

: begin ( -> a )        here ;
: while ( a -> a' a )   [compile] if swap ;
: again ( a -> )        [compile] branch ;
: repeat ( a a' -> )    [compile] again [compile] then ;

: for ( -> a a' )
   [compile] push [compile] begin [compile] r@ [compile] while ;

: next ( a a' -> )
   [compile] rdec [compile] repeat [compile] rdrop ;

: 2push ( -> )   [compile] push [compile] push ;
: 2pop ( -> )    [compile] pop [compile] pop ;
: 2dup ( -> )    [compile] over [compile] over ;


( macro -> forth )
\ We define forth words using the macros, so they can be used interactively
forth
: dup    dup ;
: drop   drop ;
: swap   swap ;
: over   over ;
: nip    nip ;

: a     a ;
: a!    a! ;
: @     @ ;
: @+    @+ ;
: b@    b@ ;
: b@+   b@+ ;
: !     ! ;
: !+    !+ ;
: b!    b! ;
: b!+   b!+ ;

: +      + ;
: -      - ;
: *      * ;
: /mod   /mod ;
: /      /mod nip ;
: mod    /mod drop ;

: lshift   lshift ;
: rshift   rshift ;


( Dictionary )
forth
: find ( a u -> a'|0 )   latest @ dfind ;

: ' ( -> a )   next-word find dup 0 = if abort0 then  cfa ;
: f' ( -> a|0 )   next-word flatest @ dfind dup 0 = if abort0 then  cfa ;

macro
: ['] ( -> )    '  [compile] lit ;
: [f'] ( -> )   f' [compile] lit ;
forth

: allot ( n -> )   here +  h ! ;

: pfa ( 'def -> 'data )   \ return a pointer to a definition's data area
   cfa 5 + ;


: (does>)   \ runtime for does>
   latest @ @ cfa
   pop swap call!   \ compile a call to the code following does>
   0 hole ! ;       \ do not transform the previous call into a jump

macro
: does>
   [f'] (does>) call,  \ compile a call to the runtime for does>

   \ at runtime R has the address of the data area for the definition,
   \ compile a pop to retrieve that address
   [compile] pop ;
forth

: created ( a u -> )
   entry,
   >cfa  here swap !  \ store next data address as the cfa
   0 call,            \ compile a dummy call
   does> ;

: create ( -> )        next-word created ;

: variable ( -> )   create 0 , ;

: ?find ( -> a )   next-word find   dup 0 = if abort then ;
: value ( -> )     create ,  does> @ ;

macro
: to ( n -> )   ?find pfa  [compile] lit [compile] ! ;
forth
: to ( n -> )   ?find pfa  ! ;

8 value cell
: cells ( -> u )   cell * ;

: marker ( -> )
   here               \ save current HERE so the marker definition removes itself
   forth create
       ,              \ 0:       dictionary pointer
       flatest @ @ ,  \ cell:    next to last forth definition
       mlatest @ ,    \ 2 cells: last macro definition
   does>
        dup        @ h !
        dup cell + @ flatest !
         2 cells + @ mlatest ! ;


( Memory utilities )
forth
: advance ( a u n -> a+n u-n )   swap over  - push + pop ;

: move ( src dst u -> )
   push push a! pop pop
   begin dup while
     over b@+ swap b!
     1 advance
   repeat
   drop drop ;

: +! ( n a -> )   swap over  @ +  swap ! ;
: mem, ( a u -> )   here over allot  swap move ;

: mem= ( a1 a2 u -> f )
   if0  drop drop drop -1 exit  then
   push  over b@ over b@ ~= if  drop drop rdrop 0 exit then
   1 + swap  1 + swap  pop 1 -  mem= ;


: align ( a u -> a' )   1 -  swap over +  swap not and ;

0 value record:
: field: ( offset size alignment -> offset+size' )
   create   swap push  align dup ,  pop +
   does> ( a -> a' )   @ + ;


( Strings )
forth
: cr ( -> )   10 emit ;
32 value bl

: char ( -> b )     bl word drop b@ ;
macro
: [char] ( -> b )   char [compile] lit ;
forth

: ," ( -> a u )       [char] " word  here swap 2dup 2push  move  2pop ;
: z" ( -> a )         ,"  over +  0 swap b! ;
: s>z ( a u -> a' )   here swap 2dup 2push  move  2pop over +  0 swap b! ;
: zlen ( a -> u )     a! 0 begin b@+ while 1 + repeat ;
: z>s ( a -> a' u )   dup zlen ;

: ." ( -> )   [char] " word type ;

: s= ( a1 u1 a2 u2 -> f )
   push swap pop over ~= if  drop drop drop 0 exit  then mem= ;

: search ( b a u -> a' u' )
   if0  push nip pop exit  then
   push  over over b@ = if  nip pop exit  then  pop
   1 advance search ;

: -tail ( b a u -> a u' )   over push search drop pop swap over - ;
: -head ( b a u -> a u' )   search  1 advance ;

macro
: slit ( a len -> )
   dup push  [compile] branch-unresolved  here push push
   \ r: len addr-of-string-start addr-of-branch-dst
   mem,  pop [compile] then  pop [compile] lit  pop [compile] lit ;

: s" ( -> )   [char] " word  [compile] slit ;
: ." ( -> )   [compile] s" [f'] type call, ;

forth
: ?abort ( flag a u -> )   2push if 2pop abort then  rdrop rdrop ;


( Pictured numeric conversion )
macro
: negate ( n -> n' )   $D8F748 3, ;  \ neg %rax

forth
: digit ( n -> n' )   dup 9 >  7 and +  48 + ;

: hold ( count rem b -> b count+1 rem )   swap push  swap 1 + pop ;

: <# ( n -> 0 n )               0 swap ;
: #  ( n -> ... count rem )     base @ /mod swap digit hold ;
: #> ( ... count rem -> a u )   asave  drop  here a!  dup push for b!+ next  here pop  arest ;
: #s ( n -> ... count rem )     begin # dup while repeat ;

: negate   negate ;
: abs ( n -> |n| )   dup 0 < if negate then ;
: sign ( n -> )   0 < if  [char] - hold  then ;

: space ( -> )   bl emit ;

: (.) ( n -> )   dup push abs <#  #s pop sign #> ;
: . ( n -> )     (.) type space ;

: depth ( -> u )   S0 sp@ - 8 /  2 - ;
: .S ( -> )   depth S0 16 - swap for  dup @ . 8 -  next drop  s" <- top " type ;


( Files )
forth
: (open-create) ( a u mode syscall# -> fd )   push push s>z pop pop syscall2 ;
: create-file ( a u mode -> fd )   85 (open-create) ;
: open-file ( a u mode -> fd )   2 (open-create) ;

: read ( a u fd -> n )   sysread ;
: read-byte ( fd -> b|-1 )
   push here 1 pop read 1 = if  here b@ exit  then -1 ;

: read-line ( a u fd -> n )
   push push a! pop pop over  for
     dup read-byte dup b!+
     dup -1 = if  drop drop pop - exit  then
         10 = if  drop pop - 1 + exit  then
   next
   drop ;

: write ( a u fd -> n )   syswrite ;
: write-byte ( b fd -> n )   push  here b!  here 1 pop write ;
: write-line ( a u fd -> n )
   dup push write  10 pop write-byte
   1 ~= if  drop -1 exit  then 1 + ;

: close ( fd -> n )   3 syscall1 ;
: position-file ( n ref fd -> n' )   swap push swap pop 8 syscall3 ;
: file-position ( fd -> n' )   push 0 1 pop position-file ;


( File loading )
: input@ ( -> fd buf tot used pos 'refill )
   infd @ inbuf @ intot @ inused @ inpos @ 'refill @ ;

: input! ( fd buf tot used pos 'refill -> )
   'refill ! inpos ! inused ! intot ! inbuf ! infd ! ;

: save-input ( -> )
   pop pop  input@ push push push push push push  push push ;

: restore-input ( -> )
   pop pop  pop pop pop pop pop pop input!  push push ;

: file-refill ( -> n )
   0 inpos !  inbuf @ intot @ infd @ read-line  dup inused ! ;

256 value /buf
create buf /buf allot

: included ( a u -> )
   'prompt @ push  0 'prompt !  save-input
   0 open-file  dup 0 <  s" can't include file" ?abort
   dup buf /buf 0 0 ['] file-refill input!
   push  readloop  pop close drop
   restore-input  pop 'prompt ! ;

: include ( -> )   10 word included ;


( Shell utilities )
: #!  [compile] \ ;

: #args ( -> u )      S0 @ @ ;
: 'arg ( u -> a )     1 + cells  S0 @ + ;
: arg ( u -> a u' )   'arg @ z>s ;
: 'env ( u -> a )     #args 1 + + 'arg @ ;

variable arg-offset
: next-arg ( -> a u )
   arg-offset @  dup #args >= if  drop 0 0 exit  then
   arg  1 arg-offset +! ;

: env-name ( a -> a u )      [char] = swap z>s -tail ;
: env-value ( a -> a' u' )   [char] = swap z>s -head ;

: (getenv) ( a u env# -> a' u'|0 )
   push  r@ 'env if0  drop drop rdrop 0 exit  then
   push 2dup pop env-name s= if  drop drop pop 'env env-value exit  then
   pop 1 + (getenv) ;

: getenv ( a u -> a' u'|0 )   0 (getenv) ;


marker empty

anon:
  #args 1 = if banner exit then
  2 arg-offset !  1 arg included bye ;
execute
