1 value RTLD_LAZY

: zlen ( a -> u )   a! 0 begin b@+ while 1 + repeat ;
: z>s ( a -> a u )   dup zlen ;

: errorstr ( -> a u )   dlerror dup if z>s exit then drop 0 0 ;
: ?clib-abort ( flag -> )   if errorstr abort then ;

: clib-load ( a u -> handle )
   s>z RTLD_LAZY dlopen dup 0 = ?clib-abort ;

: clib-symbol ( handle a u -> 'func )
   s>z dlsym dup 0 = ?clib-abort ;

: cfunc>entry ( handle a u -> 'func )
   2dup 2push  clib-symbol
   2pop entry,  here swap >cfa ! ;

: cfunc>entry ( handle Cname Clen nopname noplen -> 'func )
   2push clib-symbol  2pop entry,  here swap >cfa ! ;

: callC5   $C08949 3, ` drop ;
: callC4   $C18948 3, ` drop ;
: callC3   $C28948 3, ` drop ;
: callC2   $C68948 3, ` drop ;
: callC1   $C78948 3, ;

: abscall, ( 'func -> )
   $BB48 2, ,  \ mov $'func, %rbx
   $D3FF 2, ;  \ call *%rbx

: absjump, ( 'func -> )
   $BB48 2, ,  \ mov $'func, %rbx
   $E3FF 2, ;  \ jmp *%rbx

: callC, ( #ret #args 'func -> )
   push
   dup 5 > " too many arguments to C function" ?abort
   dup 4 > if callC5 then
   dup 3 > if callC4 then
   dup 2 > if callC3 then
   dup 1 > if callC2 then
       0 > if callC1 then
   pop swap 0 = if
      abscall,  ` drop ` exit
      exit
   then
   absjump, ;

forth

( User API )
0 value handle

: library:
   handle if handle dlclose drop then
   next-word clib-load to handle ;

: Cfunction: ( #args #ret "Cname" "nopname" -> )
   swap  handle next-word next-word cfunc>entry  callC, ;
