System calls
------------
sysread  ( a u fd -> u' )
  Read u bytes from fd into address a.
  Return number of bytes read.

syswrite  ( a u fd -> u' )
  Write u bytes starting at address a to fd.
  Return number of bytes read.

sysopen  ( a u -> fd )
  Open file named in the nul-terminated string at a with mode u.
  Return file descriptor fd.

sysclose  ( fd -> n )
  Close file descriptor fd.
  Return error n.

sysexit  ( n -> )
  Exit process with status n.


I/O
---
expect  ( a u -> u' )
  Read u bytes from standard input into address a.
  Return number of bytes read.

type  ( a u -> )
  Write u bytes starting at address a to the standard output.

emit  ( b -> )
  Write byte to the standard output.

key  ( -> b|-1 )
  Read byte from the standard input.
  Return byte or -1 if read failed.

reset-input  ( -> )
  Reset input pointers.

refill  ( -> u|0 )
  Read standard input up to a new line (ascii 10) byte or the end of input.
  Return positive number u if read was successful, 0 otherwise.
  

Memory
------
@  ( a -> n )  macro
  Fetch cell from address a.

b@  ( a -> b )  macro
  Fetch byte from address a.

!  ( n a -> )  macro
  Store cell n at address a.

b!  ( b a -> )  macro
  Store byte b at address a.

a  ( -> n )  macro
  Return contents of register a.

a!  ( n -> )  macro
  Store n into register a.

@+  ( -> n )  macro
  Fetch cell from address in register a. Increment a by cell.

b@+  ( -> b )  macro
  Fetch byte from address in register a. Increment a by 1.

!+  ( n -> )  macro
  Store n into address in register a. Increment a by cell.

b!+  ( b -> )  macro
  Store byte into address in register a. Increment a by 1.


Strings
-------
A string is defined as an address and a count on the stack.

skip  ( b a u -> a' u' )
  Skip sequence of b's in string a u.
  Return the remaining string after the sequence.

scan  ( b a u -> a' u' )
  Scan byte b in string a u.
  Return the remaining string, starting at the first b. If b was not found,
  the top of the stack is zero.

digit  ( b - n | ->1 )
  Convert ascii digit to binary number given the current base.
  If conversion succeeded, return converted number.
  If conversion didn't succeed because b was invalid related to base,
  return -1.

number  ( a u -> u' 0|>0 )
  Convert string a u to number given the current base.
  Return converted number and remaining bytes in string.
  If conversion failed, remaining bytes is greater than 0.

inbuf  ( -> a u )
  Return the input buffer.

in>  ( -> a u )
  Return the next input line from the input buffer.

word  ( b -> a u )  in:
  Skip a sequence of the delimiter byte b in the input line and return the
  string up to the next delimiter.


Dictionary
----------
The current dictionary is where definitions are compiled

flatest  ( -> a )
  Return the address of latest word defined in the forth dictionary

mlatest  ( -> a )
  Return the address of latest word defined in the macro dictionary

latest  ( -> a )
  Return the address of latest word defined in the current dictionary

macro  ( -> )
  Set macro as the current dictionary

forth  ( -> )
  Set forth as the current dictionary

,  ( n -> )
  Store word sized number in dictionary

2,  ( n -> )
  Store two-byte number in the dictionary

3,  ( n-> )
  Store three-byte number in the dictionary

4,  ( n -> )
  Store four-byte sized number in the dictionary

b,  ( b -> )
  Store byte in dictionary

centry  ( a u -> a )
  Create a new dictionary entry with name a u.
  Return the address of the entry.

entry  ( -> )  in:
  Create a new dictionary entry with name given in the input line.
  Return the address of the entry.

create  ( -> )  in:
  Create a new dictionary entry which code returns the next address in the dictionary.

dfind  ( a u da -> a'|0 )
  Find entry named a u in dictionary starting at da.
  If found, return entry address. If not, return 0.

>cfa  ( a -> a )
  Convert entry address to the entry's code field address (CFA)

here  ( -> a )
  Return the next address available in the dictionary

call,  ( a -> )  macro
  Compile a call to address a

]  ( -> )  macro
  Switch to compilation mode

[  ( -> )  macro
  Switch to execution mode

:  ( -> )  in: macro
  Create new definition with name given by next input word

anon:  ( -> a )  in:
  Create anonymous definition

exit  ( -> )  macro
  Exit defition

;  ( -> )  macro
  Compile exit and switch to execution mode


Intepreter
----------
abort  ( -> )
  Reset data and return stacks and jump to the interpreter loop.

abort"  ( n -> )
  If n is zero, do nothing.
  If not, output string delimited by " and abort.

eval  ( a u -> ... )
  Evaluate string.
  If string is valid, return the results of evaluation. If not, abort.

compile  ( a u -> ... )
  Compile string.
  If string is valid, return the result of compilation. If not, abort.

execute  ( a -> ... )
  Jump to word at address a.


Arithmetic
----------
+  macro
  Compile code for the following stack effect  ( a b -> a+b )
-  macro
  Compile code for the following stack effect  ( a b -> a-b )
*  macro
  Compile code for the following stack effect  ( a b -> a*b )
/mod  macro
  Compile code for the following stack effect  ( a b -> remainder(a,b) a/b )

Logic
-----
=  macro
  Compile code for the following stack effect  ( a b -> a=b? )

/=  macro
  Compile code for the following stack effect  ( a b -> a/=b? )

<  macro
  Compile code for the following stack effect  ( a b -> a<b? )

>  macro
  Compile code for the following stack effect  ( a b -> a>b? )

<=  macro
  Compile code for the following stack effect  ( a b -> a<=b? )

>=  macro
  Compile code for the following stack effect  ( a b -> a>=b? )

Miscellaneous
-------------
banner  ( -> )
  Output nop forth banner.

bye  ( n -> )
  Exit nop forth with zero status.

