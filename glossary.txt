System calls
------------
sysread  ( a u fd -> u' )
  Read u bytes from fd into address a.
  Return number of bytes read.

syswrite  ( a u fd -> u' )
  Write u bytes starting at address a to fd.
  Return number of bytes read.

sysopen  ( a u -> fd )
  Open file named in the nul-terminated string at a with mode u.
  Return file descriptor fd.

sysclose  ( fd -> n )
  Close file descriptor fd.
  Return error n.

sysexit  ( n -> )
  Exit process with status n.


I/O
---
expect  ( a u -> u' )
  Read u bytes from standard input into address a.
  Return number of bytes read.

type  ( a u -> )
  Write u bytes starting at address a to the standard output.

emit  ( b -> )
  Write byte to the standard output.

key  ( -> b|-1 )
  Read byte from the standard input.
  Return byte or -1 if read failed.

reset-input  ( -> )
  Reset input pointers.

refill  ( -> u|0 )
  Read standard input up to a new line (ascii 10) byte or the end of input.
  Return positive number u if read was successful, 0 otherwise.

infd  variable
  File descriptor feeding the input

inbuf  variable
  Pointer to input buffer

intot  variable
  Total number of bytes in input buffer

inused  variable
  Number of filled bytes in input buffer

inpos  variable
  Input buffer position

termbuf  variable
  Terminal input buffer

termtot  variable
  Number of bytes in terminal input buffer

source  ( -> a u )
  Return a string describing the part of the input buffer yet to be processed.


Memory
------
@  ( a -> n )  macro
  Fetch cell from address a.

b@  ( a -> b )  macro
  Fetch byte from address a.

!  ( n a -> )  macro
  Store cell n at address a.

b!  ( b a -> )  macro
  Store byte b at address a.

a  ( -> n )  macro
  Return contents of register a.

a!  ( n -> )  macro
  Store n into register a.

@+  ( -> n )  macro
  Fetch cell from address in register a. Increment a by cell.

b@+  ( -> b )  macro
  Fetch byte from address in register a. Increment a by 1.

!+  ( n -> )  macro
  Store n into address in register a. Increment a by cell.

b!+  ( b -> )  macro
  Store byte into address in register a. Increment a by 1.

move  ( src dst u -> )
  Copy u bytes from src to dst.


Strings
-------
A string is defined as an address and a count on the stack.

skip  ( a u b -> a' u' )
  Skip sequence of the byte b in string a u.
  Return the remaining string after the sequence.

scan  ( a u b -> a' u' )
  Scan byte b in string a u.
  Return the remaining string, starting at the first b. If b was not found,
  the top of the stack is zero.

digit  ( b -> n|-1 )
  Convert ascii digit to binary number given the current base.
  If conversion succeeded, return converted number. If not, return -1.

number  ( a u -> u' 0|>0 )
  Convert string a u to number given the current base.
  Return converted number and remaining bytes in string.
  If conversion failed, remaining bytes is greater than 0.

word  ( b -> a u )  in:
  Skip a sequence of the delimiter byte b in the input line and return the
  string up to the next delimiter.


Dictionary
----------
The current dictionary is where definitions are compiled

flatest  ( -> a )
  Return the address of latest word defined in the forth dictionary

mlatest  ( -> a )
  Return the address of latest word defined in the macro dictionary

latest  ( -> a )
  Return the address of latest word defined in the current dictionary

macro  ( -> )
  Set macro as the current dictionary

forth  ( -> )
  Set forth as the current dictionary

,  ( n -> )
  Store cell sized number in dictionary

2,  ( n -> )
  Store two-byte number in the dictionary

3,  ( n -> )
  Store three-byte number in the dictionary

4,  ( n -> )
  Store four-byte number in the dictionary

b,  ( b -> )
  Store byte in dictionary

centry  ( a u -> a' )
  Create a new dictionary entry with name a u.
  Return the address of the entry.

entry  ( -> )  in:
  Create a new empty entry in the current dictionary with the name given in the
  next input word

create  ( -> )  in:
  Create a new entry in the current dictionary with name given in the next input
  word. When executed, the entry returns the address after its header.

dfind  ( a1 u a2 -> a|0 )
  Find entry named a1 u in dictionary starting at a2.
  If found, return the entry's address. If not, return 0.

found  ( a u -> a'|0 )
  Search the current dictionary for the entry named a u.
  If found, return the entry's address. If not, return 0.

find  ( -> a'|0 ) in:
  Search the current dictionary for the entry named by the next input word.
  If found, return the entry's address. If not, abort.

'  ( -> a'|0 )  in:
  Search the current dictionary for the entry named by the next input word.
  If found, return the entry's code field address (CFA). If not, return 0.

[']  ( -> )  macro
  Search the current dictionary for the entry named by the next input word.
  If found, compile the entry's code field address (CFA). If not, abort.

>cfa  ( a -> a' )
  Convert entry address to the entry's code field address (CFA)

here  ( -> a )
  Return the next address available in the dictionary

call,  ( a -> )  macro
  Compile a call to address a

]  ( -> )  macro
  Switch to compilation mode

[  ( -> )  macro
  Switch to execution mode

:  ( -> )  in:  macro
  Create new definition with name given by the next input word

anon:  ( -> a )  in:
  Create anonymous definition.
  Return address of the definition.

exit  ( -> )  macro
  Exit defition

;  ( -> )  macro
  Compile exit and switch to execution mode


Intepreter
----------
abort  ( -> )
  Reset data and return stacks and jump to the interpreter loop

abort"  ( n -> )
  If n is zero, do nothing.
  If not, output string delimited by " and abort.

eval  ( a u -> ... )
  Evaluate string as the interpreter would.
  When executing:
  1. Search the word in the forth dictionary
  2. If found, execute it
  3. If not, search in the macro dictionary
  4. If found, execute it
  5. If not, convert to number
  6. If conversion succeeded, push number to stack
  7. If not, abort

  When compiling:
  1. Search the word in the macro dictionary
  2. If found, execute it
  3. If not, search in the forth dictionary
  4. If found, compile it
  5. If not, convert to number
  6. If conversion succeeded, compile literal
  7. If not, abort

  The itens left on the stack are the results from the evaluation.

execute  ( a -> ... )
  Jump to word at address a


Arithmetic
----------
+  macro
  Compile code for the following stack effect  ( a b -> a+b )
-  macro
  Compile code for the following stack effect  ( a b -> a-b )
*  macro
  Compile code for the following stack effect  ( a b -> a*b )
/mod  macro
  Compile code for the following stack effect  ( a b -> remainder(a,b) a/b )


Logic
-----
=  macro
  Compile code for the following stack effect  ( a b -> a=b? )

/=  macro
  Compile code for the following stack effect  ( a b -> a/=b? )

<  macro
  Compile code for the following stack effect  ( a b -> a<b? )

>  macro
  Compile code for the following stack effect  ( a b -> a>b? )

<=  macro
  Compile code for the following stack effect  ( a b -> a<=b? )

>=  macro
  Compile code for the following stack effect  ( a b -> a>=b? )


Miscellaneous
-------------
banner  ( -> )
  Output nop forth banner

hex  ( -> )
  Set base to 16

decimal  ( -> )
  Set base to 10

bye  ( n -> )
  Exit nop forth with zero status

